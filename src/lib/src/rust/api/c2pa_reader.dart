// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'c2pa_reader.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `check_json_for_ai_indicators`, `detect_ai_generation`, `error`, `extract_cert_field`, `extract_generator_from_json`, `extract_model_name`, `no_manifest_with_exif`, `no_manifest`, `parse_exif_from_bytes`, `parse_exif_from_file`, `parse_manifest_reader`, `software_agent_to_string`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Analyzes a file at the given path for C2PA metadata
C2paAnalysisResult analyzeC2PaFromPath({required String filePath}) => RustLib
    .instance
    .api
    .crateApiC2PaReaderAnalyzeC2PaFromPath(filePath: filePath);

/// Analyzes raw bytes for C2PA metadata
C2paAnalysisResult analyzeC2PaFromBytes({
  required List<int> data,
  required String mimeType,
}) => RustLib.instance.api.crateApiC2PaReaderAnalyzeC2PaFromBytes(
  data: data,
  mimeType: mimeType,
);

/// Returns the C2PA SDK version
String c2PaSdkVersion() =>
    RustLib.instance.api.crateApiC2PaReaderC2PaSdkVersion();

/// Check if the native library is properly loaded
bool isC2PaAvailable() =>
    RustLib.instance.api.crateApiC2PaReaderIsC2PaAvailable();

/// AI generation information
class AiInfo {
  final bool isAiGenerated;
  final String? generatorName;
  final String? modelName;
  final String? detectionSource;

  const AiInfo({
    required this.isAiGenerated,
    this.generatorName,
    this.modelName,
    this.detectionSource,
  });

  @override
  int get hashCode =>
      isAiGenerated.hashCode ^
      generatorName.hashCode ^
      modelName.hashCode ^
      detectionSource.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AiInfo &&
          runtimeType == other.runtimeType &&
          isAiGenerated == other.isAiGenerated &&
          generatorName == other.generatorName &&
          modelName == other.modelName &&
          detectionSource == other.detectionSource;
}

/// The full C2PA analysis result
class C2paAnalysisResult {
  final VerificationStatus status;
  final SignerInfo? signer;
  final List<ContentAction> actions;
  final AiInfo? aiInfo;
  final ExifInfo? exifInfo;
  final String? claimGenerator;
  final String? title;
  final String? format;
  final String? instanceId;
  final String? rawManifestJson;

  const C2paAnalysisResult({
    required this.status,
    this.signer,
    required this.actions,
    this.aiInfo,
    this.exifInfo,
    this.claimGenerator,
    this.title,
    this.format,
    this.instanceId,
    this.rawManifestJson,
  });

  @override
  int get hashCode =>
      status.hashCode ^
      signer.hashCode ^
      actions.hashCode ^
      aiInfo.hashCode ^
      exifInfo.hashCode ^
      claimGenerator.hashCode ^
      title.hashCode ^
      format.hashCode ^
      instanceId.hashCode ^
      rawManifestJson.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is C2paAnalysisResult &&
          runtimeType == other.runtimeType &&
          status == other.status &&
          signer == other.signer &&
          actions == other.actions &&
          aiInfo == other.aiInfo &&
          exifInfo == other.exifInfo &&
          claimGenerator == other.claimGenerator &&
          title == other.title &&
          format == other.format &&
          instanceId == other.instanceId &&
          rawManifestJson == other.rawManifestJson;
}

/// A single action in the content's edit history
class ContentAction {
  final String action;
  final String? softwareAgent;
  final String? when;
  final String? description;

  const ContentAction({
    required this.action,
    this.softwareAgent,
    this.when,
    this.description,
  });

  @override
  int get hashCode =>
      action.hashCode ^
      softwareAgent.hashCode ^
      when.hashCode ^
      description.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ContentAction &&
          runtimeType == other.runtimeType &&
          action == other.action &&
          softwareAgent == other.softwareAgent &&
          when == other.when &&
          description == other.description;
}

/// EXIF metadata result
class ExifInfo {
  final String? software;
  final String? make;
  final String? model;
  final String? artist;
  final String? copyright;
  final String? userComment;
  final String? imageDescription;
  final String? dateTimeOriginal;
  final bool aiDetected;
  final String? aiGenerator;

  const ExifInfo({
    this.software,
    this.make,
    this.model,
    this.artist,
    this.copyright,
    this.userComment,
    this.imageDescription,
    this.dateTimeOriginal,
    required this.aiDetected,
    this.aiGenerator,
  });

  @override
  int get hashCode =>
      software.hashCode ^
      make.hashCode ^
      model.hashCode ^
      artist.hashCode ^
      copyright.hashCode ^
      userComment.hashCode ^
      imageDescription.hashCode ^
      dateTimeOriginal.hashCode ^
      aiDetected.hashCode ^
      aiGenerator.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ExifInfo &&
          runtimeType == other.runtimeType &&
          software == other.software &&
          make == other.make &&
          model == other.model &&
          artist == other.artist &&
          copyright == other.copyright &&
          userComment == other.userComment &&
          imageDescription == other.imageDescription &&
          dateTimeOriginal == other.dateTimeOriginal &&
          aiDetected == other.aiDetected &&
          aiGenerator == other.aiGenerator;
}

/// Information about the content signer
class SignerInfo {
  final String? name;
  final String? organization;
  final String? issuedBy;
  final String? timestamp;

  const SignerInfo({
    this.name,
    this.organization,
    this.issuedBy,
    this.timestamp,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      organization.hashCode ^
      issuedBy.hashCode ^
      timestamp.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SignerInfo &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          organization == other.organization &&
          issuedBy == other.issuedBy &&
          timestamp == other.timestamp;
}

@freezed
sealed class VerificationStatus with _$VerificationStatus {
  const VerificationStatus._();

  const factory VerificationStatus.verified() = VerificationStatus_Verified;
  const factory VerificationStatus.signatureInvalid() =
      VerificationStatus_SignatureInvalid;
  const factory VerificationStatus.certificateExpired() =
      VerificationStatus_CertificateExpired;
  const factory VerificationStatus.certificateUntrusted() =
      VerificationStatus_CertificateUntrusted;
  const factory VerificationStatus.noManifest() = VerificationStatus_NoManifest;
  const factory VerificationStatus.error({required String message}) =
      VerificationStatus_Error;
}
